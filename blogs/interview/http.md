---
title: Http篇
date: 2022-01-20
sidebar: true
categories:
    - 前端
tags:
    - 面试
publish: false
---

## tcp和udp的区别
| | TCP | UDP |
| :--- | :----: | :----: |
| 是否连接 | 面向连接 | 无连接 |
| 是否可靠 | 可靠 | 不可靠 |
| 连接对象个数 | 只能一对一通信 | 支持一对一、一对多、多对一，多对多交互通信 |
| 传输方式 | 面向字节流 | 面向报文 |
| 首部开销 | 首部开销比较大，最小20个字节，最大60 | 首部开销小，仅8个字节 |
| 使用场景 | 适用于可靠传输的应用,如文件 | 适用于实时应用，如视频会议 |

## 什么是HTTP? HTTP和HTTPS的区别?
### HTTP
HTTP (HyperText Transfer Protocol)，即超文本运输协议，是实现网络通信的一种规范
+ 支持客户/服务器模式
+ 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快
+ 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记
+ 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间
+ 无状态：HTTP协议无法根据之前的状态进行本次的请求处理
### HTTPS
为了保证这些隐私数据能加密传输，让HTTP运行安全的SSL/TLS协议上，即 HTTPS = HTTP + SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密

### 区别
+ HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全
+ HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443
+ HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP
+ HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高

## HTTP1.0、HTTP1.1和HTTP2.0的区别
### HTTP1.0
+ 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接
### HTTP1.1
+ 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用
+ 在同一个TCP连接里面，客户端可以同时发送多个请求
+ 虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着
+ 新增了一些请求方法
+ 新增了一些请求头和响应头
### HTTP2.0
+ 采用二进制格式而非文本格式
+ 完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行
+ 使用报头压缩，降低开销
+ 服务器推送

## GET和POST的区别
| | GET | POST |
| :--- | :----: | :----: |
| 后退按钮/刷新 | 无害 | 数据会被重新提交（浏览器应该告知用户数据会被重新提交） |
| 书签 | 可收藏为书签 | 不可收藏为书签 |
| 缓存 | 能被缓存 | 不能缓存 |
| 历史 | 参数保留在浏览器历史中 | 参数不会保存在浏览器历史中 |
| 对数据长度的限制 | 当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）| 无限制 |
| 对数据类型的限制 | 只允许**ASCII**字符 | 没有限制。也允许二进制数据 |
| 安全性 | 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET | POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中 |
| 可见性 | 数据在 URL 中对所有人都是可见的 | 数据不会显示在 URL 中 |

## 地址栏从输入到页面渲染发生了什么
+ URL解析
+ DNS查询
+ TCP连接: 三次握手
    - 客户端给服务端发一个**SYN**报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于**SYNSENT**状态
    - 服务器收到客户端的**SYN**报文之后，会以自己的**SYN**报文作为应答，为了确认客户端的**SYN**将客户端的 ISN+1作为ACK的值，此时服务器处于**SYNRCVD**的状态
    - 客户端收到**SYN**报文之后，会发送一个**ACK**报文，值为服务器的ISN+1。此时客户端处于**ESTABLISHED**状态。服务器收到**ACK**报文之后，也处于**ESTABLISHED**状态，此时，双方已建立起了连接
    <div>![](/imgs/interview/connet_on.png)</div>
+ HTTP请求
+ 响应请求
+ 页面渲染
    - 根据HTML解析出DOM tree
        + DOM tree解析的过程是一个深度优先遍历
        + 构建DOM tree的过程中，若遇到script标签，则DOM tree的构建会暂停，直至脚本执行完毕
    - 根据CSS解析生成CSS tree
        + 解析CSS tree时js执行将暂停，直至CSS tree就绪
        + 浏览器在CSS tree生成之前不会进行渲染
    - 结合DOM tree和CSS tree，生成render tree
        + DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树
        + 精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度
    - 根据render tree计算每一个节点的信息
        + 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸
        + 回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染
    - 根据计算好的信息绘制页面
        + 绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上
        + 重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。
        + 回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染
+ 断开连接: 四次挥手
    - 客户端发送一个**FIN**报文，报文中会指定一个序列号。此时客户端处于**FIN_WAIT1**状态，停止发送数据，等待服务端的确认
    - 服务端收到**FIN**之后，会发送**ACK**报文，且把客户端的序列号值+1作为**ACK**报文的序列号值，表明已经收到客户端的报文了，此时服务端处于**CLOSE_WAIT**状态
    - 如果服务端也想断开连接了，和客户端的第一次挥手一样，发给**FIN**报文，且指定一个序列号。此时服务端处于**LAST_ACK**的状态
    - 客户端收到**FIN**之后，一样发送一个**ACK**报文作为应答，且把服务端的序列号值 +1 作为自己**ACK**报文的序列号值，此时客户端处于**TIME_WAIT**状态。需要过一阵子以确保服务端收到自己的**ACK**报文之后才会进入**CLOSED**状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于**CLOSED**状态
    <div>![](/imgs/interview/connet_off.png)</div>

### 为什么不是两次握手？
如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到，并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源
## 说说对websocket的理解以及应用场景
> WebSocket，是一种网络传输协议，位于OSI模型的应用层。可在单个TCP连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅
>> 客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输
### 特点
+ 全双工：通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合
+ 二进制帧：采用了二进制帧结构，语法、语义与 HTTP 完全不兼容，相比http/2，WebSocket更侧重于“实时通信”，而HTTP/2 更侧重于提高传输效率，所以两者的帧结构也有很大的区别
+ 协议名：引入ws和wss分别代表明文和密文的websocket协议，且默认端口使用80或443，几乎与http一致
### 优点
+ 较少的控制开销：数据包头部协议较小，不同于http每次请求需要携带完整的头部
+ 更强的实时性：相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少
+ 保持创连接状态：创建通信后，可省略状态信息，不同于HTTP每次请求需要携带身份验证
+ 更好的二进制支持：定义了二进制帧，更好处理二进制内容
+ 支持扩展：用户可以扩展websocket协议、实现部分自定义的子协议
+ 更好的压缩效果：Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率
### 应用场景
+ 弹幕
+ 媒体聊天
+ 协同编辑
+ 实况/实时更新

## 说说强缓存和协商缓存的区别
### 强缓存
> 直接从本地副本比对读取，不去请求服务器，返回的状态码是 200

### 协商缓存
> 会去服务器比对，若没改变才直接读取本地缓存，返回的状态码是 304